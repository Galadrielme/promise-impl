{
  "version": 3,
  "sources": ["../main.ts", "../src/enum/PromiseState.ts", "../src/enum/PromiseStateLabel.ts", "../src/utils/state.ts", "../src/utils/define.ts", "../src/utils/types.ts", "../src/utils/bail.ts", "../src/kernel/utils.ts", "../src/kernel/index.ts", "../src/assert/assertPromiseExecutor.ts", "../src/promise/implements/constructor.ts", "../src/utils/await.ts", "../src/utils/execute.ts", "../src/utils/microTask.ts", "../src/assert/assertResolveAndRejectCallable.ts", "../src/assert/assertWithResolvers.ts", "../src/promise/implements/Promise.withResolvers.ts", "../src/assert/assertConstructorSpecies.ts", "../src/utils/species.ts", "../src/promise/implements/Promise#then.ts", "../src/promise/implements/Promise#catch.ts", "../src/promise/implements/Promise#finally.ts", "../src/promise/implements/Promise.resolve.ts", "../src/promise/implements/Promise.reject.ts", "../src/assert/assertIterable.ts", "../src/promise/implements/Promise.allSettled.ts", "../src/promise/implements/Promise.all.ts", "../src/promise/implements/Promise.race.ts", "../src/promise/implements.ts", "../src/promise/index.ts"],
  "sourcesContent": ["import Promise from \"./src/promise\";\nimport PromiseKernel from \"./src/kernel\";\n\nexport default Promise;\nexport {\n    PromiseKernel\n};", "const enum PromiseState {\n    PENDING = 0,\n    FULFILLED = 1,\n    REJECTED = 2\n}\n\nexport default PromiseState;", "/** promise\u72B6\u6001\u7684\u540D\u79F0 */\nconst enum PromiseStateLabel {\n    PENDING = \"pending\",\n    FULFILLED = \"fulfilled\",\n    REJECTED = \"rejected\"\n}\n\nexport default PromiseStateLabel;", "import PromiseState from \"../enum/PromiseState\";\nimport PromiseStateLabel from \"../enum/PromiseStateLabel\";\n\n/**\n * \u683C\u5F0F\u5316Promise\u7684\u72B6\u6001\n * \n * @param { PromiseState } state \n * @returns { PromiseStateLabel }\n */\nexport function formatPromiseState (state: PromiseState): PromiseStateLabel {\n    switch (state) {\n        case PromiseState.PENDING: return PromiseStateLabel.PENDING;\n        case PromiseState.FULFILLED: return PromiseStateLabel.FULFILLED;\n        case PromiseState.REJECTED: return PromiseStateLabel.REJECTED;\n        default: throw `Unexpected PromiseState with ${ state }`;\n    }\n}", "export function defineConstant (source: any, key: PropertyKey, value: any) {\n    Object.defineProperty(source, key, { value, writable: false, enumerable: false, configurable: false });\n}\nexport function defineConfigurable (source: any, key: PropertyKey, value: any) {\n    Object.defineProperty(source, key, { value, writable: false, enumerable: false, configurable: true });\n}\nexport function defineUnenumerable (source: any, key: PropertyKey, value: any) {\n    Object.defineProperty(source, key, { value, writable: true, enumerable: false, configurable: true });\n}", "export function isFunction (o: any): o is Function {\n    return typeof o === \"function\";\n}\n\nexport function isObjectLike (o: any): o is PromiseLike<any> {\n    return typeof o === \"object\" && o !== null;\n}\n\nexport function isPromiseLike (o: any): o is PromiseLike<any> {\n    return o ? isFunction(o.then) : false;\n}\n\nexport function isNative (o: any): boolean {\n    return isFunction(o) && /native code/.test(o.toString());\n}\n\nexport function isIterable (o: any): boolean {\n    return !!(o && isFunction(o[Symbol.iterator]));\n}\n\n  \n/**\n * \u83B7\u53D6\u9519\u8BEF\u7684\u6267\u884C\u5668\u7C7B\u578B\u8F93\u51FA\n * \n * @param { any } executor \n * @param { string } type\n */\nexport function getWrongType (executor: any, type: string) {\n    if (type === \"object\") {\n        if (executor === null) return \"null\";\n        const type = Object.prototype.toString.call(executor);\n        const tag = type.slice(8, -1);\n        if (NATIVE_TYPES.has(tag) && isNative(executor.constructor)) {\n            return `#<${ tag }>`;\n        }\n        return type\n    }\n    return String(executor);\n}\n\n/** \u4E00\u4E9B\u9700\u8981\u663E\u793A\u4E3A `#<${ type }>` \u7684\u7C7B\u578B\u679A\u4E3E */\nexport const NATIVE_TYPES = new Set([\n    \"Object\",\n    \"Map\",\n    \"Set\",\n    \"Blob\",\n    \"ArrayBuffer\",\n    \"Promise\"\n]);", "/**\n * \u786E\u4FDD onfulfilled / onrejected \u53EA\u4F1A\u8C03\u7528\u4E00\u4E2A\n * \n * @param { Function } onfulfilled \n * @param { Function } onrejected \n */\nexport function bail (onfulfilled: (value: any) => void, onrejected: (reason: any) => void) {\n    const bailed = {\n        invoked: false,\n        onfulfilled: (value: any) => {\n            !bailed.invoked && (bailed.invoked = true, onfulfilled(value));\n        },\n        onrejected: (reason: any) => {\n            !bailed.invoked && (bailed.invoked = true, onrejected(reason));\n        }\n    }\n    return bailed;\n}", "import PromiseKernel from \".\";\nimport PromiseState from \"../enum/PromiseState\";\nimport { isPromiseLike } from \"../utils/types\";\nimport { bail } from \"../utils/bail\";\n\n//#region PromiseKernel \u76F8\u5173\u79C1\u6709\u51FD\u6570\n/**\n * \u63A5\u53D7\u503C\n * \n * @param { PromiseKernel } kernel \n * @param { any } value \n */\nexport function _resolve (kernel: PromiseKernel, value: any) {\n    if (isPromiseLike(value)) {\n        _asyncFulfilled(kernel, value);\n    } else {\n        _fulfilled(kernel, value);\n    }\n}\n\n/**\n * \u5F02\u6B65PromiseLike\u7684\u5B9E\u73B0, \u53EF\u80FD\u56DE\u8FDB\u4E00\u6B65\u8C03\u7528_resolve, \u76F4\u5230\u5F7B\u5E95\u5B8C\u6210\u4E3A\u6B62\n * \n * @param { PromiseKernel } kernel \n * @param { any } value \n */\nexport function _asyncFulfilled (kernel: PromiseKernel, value: PromiseLike<any>)  {\n    const bailed = bail((value) => { _resolve(kernel, value) }, (reason) => { _rejected(kernel, reason) })\n    try {\n      value.then(bailed.onfulfilled, bailed.onrejected);\n    } catch (error) {\n      bailed.onrejected(error);\n    }\n}\n\n/**\n * \u6210\u529F\u4E4B\u540E\u7684\u5904\u7406\u903B\u8F91\n * \n * @param { PromiseKernel } kernel \n * @param { any } value \n */\nexport function _fulfilled (kernel: PromiseKernel, value: any) {\n    kernel.state = PromiseState.FULFILLED;\n    kernel.result = value;\n    _emitFinally(kernel);\n}\n\n/**\n * \u5931\u8D25\u4E4B\u540E\u7684\u5904\u7406\u903B\u8F91\n * \n * @param { PromiseKernel } kernel \n * @param { any } reason \n */\nexport function _rejected (kernel: PromiseKernel, reason: any) {\n    kernel.state = PromiseState.REJECTED;\n    kernel.result = reason;\n    _emitFinally(kernel);\n}\n\n/**\n * \u5904\u7406\u56DE\u8C03\n * \n * @param { PromiseKernel } kernel \n * @param { Function } onfulfilled \n * @param { Function } onrejected \n */\nexport function _callback (kernel: PromiseKernel, onfulfilled: (value: any) => void, onrejected: (reason: any) => void) {\n    _onFinally(kernel, () => {\n        if (kernel.state === PromiseState.FULFILLED) {\n            onfulfilled(kernel.result);\n        } else if (kernel.state === PromiseState.REJECTED) {\n            onrejected(kernel.result);\n        }\n    });\n}\n\n/**\n * \u5B8C\u6210\u4E4B\u540E\u7684\u4E8B\u4EF6\n * \n * @param { PromiseKernel } kernel \n * @param { Function } callback \n */\nexport function _onFinally (kernel: PromiseKernel, callback: (kernel: PromiseKernel) => void) {\n    if (kernel.state === PromiseState.PENDING) {\n        (kernel.callbacks || (kernel.callbacks = [])).push(callback);\n    } else {\n        callback(kernel);\n    }\n}\n\n/**\n * \u89E6\u53D1\u5B8C\u6210\u4E4B\u540E\u7684\u56DE\u8C03\n * \n * @param { Function } kernel \n */\nexport function _emitFinally (kernel: PromiseKernel) {\n    if (kernel.callbacks) {\n        [...kernel.callbacks].forEach(callback => callback(kernel));\n        kernel.callbacks.length = 0;\n        kernel.callbacks = void 0;\n    }\n}\n//#endregion\n", "import PromiseState from \"../enum/PromiseState\";\nimport { _callback, _rejected, _resolve } from \"./utils\";\n\nclass PromiseKernel {\n    /** \u5185\u90E8\u72B6\u6001\u4F4D */\n    state: PromiseState;\n    /** \u5904\u7406\u540E\u7684\u503C */\n    result: any;\n    /** \u662F\u5426\u8C03\u7528\u8FC7 */\n    invoked: boolean;\n    /** \u56DE\u8C03 */\n    callbacks?: ((kernel: PromiseKernel) => void)[] | void;\n  \n    constructor () {\n        this.state = PromiseState.PENDING;\n        this.result = void 0;\n        this.callbacks = void 0;\n        this.invoked = false;\n    }\n\n    //#region settled\n    /**\n     * \u662F\u5426\u786E\u5B9A\u4E0B\u6765\u4E86\n     */\n    get settled (): boolean {\n        return this.state === PromiseState.FULFILLED || this.state === PromiseState.REJECTED;\n    }\n    //#endregion\n\n    //#region resolve / reject\n    /**\n     * \u63A5\u6536\u7ED3\u679C\n     * \n     * @param { any } value\n     */\n    resolve (value: any) {\n        /** \u53EA\u6709\u5728pending\u72B6\u6001\u624D\u8FDB\u4E00\u6B65\u5904\u7406 */\n        if (this.invoked) return;\n        this.invoked = true;\n        _resolve(this, value);\n    }\n  \n    /**\n     * \u62D2\u7EDD\n     * \n     * @param { any } reason\n     */\n    reject (reason: any) {\n        /** \u53EA\u6709\u5728pending\u72B6\u6001\u624D\u8FDB\u4E00\u6B65\u5904\u7406 */\n        if (this.state !== PromiseState.PENDING) return;\n        this.invoked = true;\n        _rejected(this, reason);\n    }\n    //#endregion\n\n    //#region callback\n    /**\n     * \u6267\u884C\u56DE\u8C03\n     * \n     * @param { Function } fulfilled \n     * @param { Function } rejected \n     */\n    callback (fulfilled: (value: any) => void, rejected: (reason: any) => void) {\n      _callback(this, fulfilled, rejected);\n    }\n    //#endregion\n}\n\nexport default PromiseKernel;", "import { getWrongType } from \"../utils/types\";\n\n/**\n * \u6821\u9A8C new Promise \u5165\u53C2\n * \n * @param { any } executor \n * @throws { TypeError } \n */\nexport function assertPromiseExecutor (executor: any)  {\n    const type = typeof executor;\n    if (type === \"function\") return;\n    throw new TypeError(`Promise resolver ${ getWrongType(executor, type) } is not a function`);\n}", "import PromiseKernel from \"../../kernel\";\nimport { assertPromiseExecutor } from \"../../assert/assertPromiseExecutor\";\nimport { defineConstant } from \"../../utils/define\";\nimport type PromiseImpl from \"../index\";\n\n/**\n * Promise#constructor\n * \n * @param { Function } executor \n * @returns { PromiseImpl }\n */\nexport default function constructorImpl (this: PromiseImpl<any>, executor: (resolve: (value: any) => void, reject: (reason?: any) => void) => void | null | undefined) {\n    {\n        assertPromiseExecutor(executor);\n    }\n  \n    const kernel = new PromiseKernel();\n    /** \u5B9A\u4E49\u6838\u5FC3\u79C1\u6709\u5C5E\u6027 */\n    defineConstant(this, \"_\", kernel);\n\n    try {\n        executor((value) => { kernel.resolve(value); }, reason => { kernel.reject(reason); });\n    } catch (e) {\n        kernel.reject(e);\n    }\n}", "import { bail } from \"./bail\";\nimport { isPromiseLike } from \"./types\";\n\n/**\n * \u5904\u7406\u5F02\u6B65\u56DE\u8C03\n * \n * @param { any } value \n * @param { Function } onfulfilled \n * @param { Function } onrejected \n */\nexport function awaitCallback (value: any, onfulfilled: (value: any) => void, onrejected: (reason: any) => void) {\n    if (isPromiseLike(value)) {\n      const bailed = bail((value) => { awaitCallback(value, onfulfilled, onrejected); }, onrejected);\n      try {\n        value.then(bailed.onfulfilled, bailed.onrejected);\n      } catch (e) {\n        bailed.onrejected(e);\n      }\n    } else {\n      onfulfilled(value);\n    }\n}", "import { awaitCallback } from \"./await\";\n\n/**\n * \u6267\u884C\n * \n * @param { any } value \n * @param { Function } execute \n * @param { Function } onfulfilled \n * @param { Function } onrejected \n */\nexport function executePromiseValue (value: any, execute: (value: any) => any, onfulfilled: (value: any) => void, onrejected: (reason: any) => void) {\n    try {\n      const result = execute(value);\n      awaitCallback(result, onfulfilled, onrejected);\n    } catch (e) {\n      onrejected(e);\n    }\n  }", "import { isNative } from \"./types\";\n\n/** \u5B9A\u4E49\u7684\u56DE\u8C03\u51FD\u6570 */\nconst callbacks: VoidFunction[] = [];\n\n/** \u5B9E\u9645\u7684\u8FD0\u884C\u5B9E\u73B0(\u53C2\u8003\u4E86vue2) */\nlet run = () => {\n    if (typeof MutationObserver !== 'undefined' && (\n        isNative(MutationObserver) ||\n        // PhantomJS and iOS 7.x\n        MutationObserver.toString() === '[object MutationObserverConstructor]'\n    )) {\n        let counter = 1;\n        const observer = new MutationObserver(flushCallbacks);\n        const textNode = document.createTextNode(String(counter));\n        observer.observe(textNode, {\n            characterData: true\n        });\n        run = function () {\n            counter = (counter + 1) % 2;\n            textNode.data = String(counter);\n        };\n    } else {\n        run = function () {\n            setTimeout(flushCallbacks, 0);\n        };\n    }\n    run();\n}\n\n/**\n * \u51B2\u6D17\u56DE\u8C03\u51FD\u6570\n */\nfunction flushCallbacks () {\n    const copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n        copies[i]();\n    }\n}\n\n/**\n * \u83B7\u53D6microTask\u56DE\u8C03\n * \n * @param { VoidFunction } callback \n */\nexport function microTask (callback: VoidFunction) {\n    callbacks.push(callback);\n    run();\n}\nmicroTask.flush = flushCallbacks;", "import { isFunction } from \"../utils/types\";\n\n/**\n * \u6821\u9A8C\u662F\u5426\u6267\u884C\n * \n * @param { boolean } resolve \n * @param { boolean } reject \n * @throws { TypeError }\n */\nexport function assertResolveAndRejectCallable (resolve: any, reject: any) {\n    if (!isFunction(resolve) && !isFunction(reject)) {\n        throw new TypeError(`Promise resolve or reject function is not callable`);\n    }\n}", "import { isFunction, isObjectLike } from \"../utils/types\";\n\n/**\n * \u65AD\u8A00Promise.withResolvers\u7684this\u5BF9\u8C61\n * \n * @param { any } ctor\n * @throws { TypeError }\n */\nexport function assertWithResolvers (ctor: any) {\n    if (!isObjectLike(ctor) && !isFunction(ctor)) {\n        throw new TypeError(\"Promise.withResolvers called on non-object\");\n    }\n}", "import { assertResolveAndRejectCallable } from \"../../assert/assertResolveAndRejectCallable\";\nimport { assertWithResolvers } from \"../../assert/assertWithResolvers\";\n\nexport default function withResolvers<T>(this: any): PromiseWithResolvers<T> {\n    {\n        assertWithResolvers(this);\n    }\n\n    let invoked = false;\n    let resolve!: PromiseWithResolvers<T>[\"resolve\"];\n    let reject!: PromiseWithResolvers<T>[\"reject\"];\n\n    const promise: any = new this((_resolve, _reject) => {\n        if (invoked) {\n            throw new TypeError(`Promise executor has already been invoked with non-undefined arguments`);\n        }\n        invoked = true;\n        resolve = _resolve;\n        reject = _reject;\n    });\n\n    {\n        assertResolveAndRejectCallable(resolve, reject);\n    }\n\n    return {\n        promise,\n        resolve,\n        reject\n    }\n}", "\n/**\n * \u6821\u9A8CPromise[Symbol.species]\n * \n * @param { any } species \n * @throws { TypeError }\n */\nexport function assertConstructorSpecies (species: any) {\n    if (typeof species !== \"function\") {\n        throw new TypeError(`object.constructor[Symbol.species] is not a constructor`);\n    }\n}", "import { assertConstructorSpecies } from \"../assert/assertConstructorSpecies\";\n\n/**\n * \u83B7\u53D6\n * \n * @param {  } ctor \n * @returns { PromiseConstructor }\n * @throws { TypeError }\n */\nexport function getPromiseSpecies (ctor: PromiseConstructor): PromiseConstructor {\n    let species = ctor[Symbol.species];\n    if (species != null) {\n        {\n          assertConstructorSpecies(species);\n        }\n        return species;\n    }\n    return ctor\n}", "import { executePromiseValue } from \"../../utils/execute\";\nimport { microTask } from \"../../utils/microTask\";\nimport withResolversImpl from \"./Promise.withResolvers\";\nimport type PromiseImpl from \"../index\";\nimport { getPromiseSpecies } from \"../../utils/species\";\nimport constructorImpl from './constructor';\n\n/**\n * Promise#then\n * \n * @param { Function } onfulfilled \n * @param { Function } onrejected \n * @returns { PromiseImpl }\n */\nexport default function thenImpl<TResult1 = any, TResult2 = never>(this: PromiseImpl<any>, onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2> {\n    const { promise, resolve, reject } = withResolversImpl.call(getPromiseSpecies((this as any).constructor));\n    {\n        this._.callback((value: any) => {\n            if (typeof onfulfilled === \"function\") {\n            microTask(() => { \n                executePromiseValue(value, onfulfilled, resolve, reject);\n            });\n            } else { resolve(value); }\n        }, (reason: any) => {\n            if (typeof onrejected === \"function\") {\n            microTask(() => {\n                executePromiseValue(reason, onrejected, resolve, reject);\n            })\n            } else { reject(reason); }\n        });\n    }\n    return promise as Promise<TResult1 | TResult2>;\n}", "import type PromiseImpl from \"../index\";\n\n/**\n * Promise#catch\n * \n * @param { Function } onrejected \n * @returns { PromiseImpl }\n */\nexport default function catchImpl<TResult = never>(this: PromiseImpl<any>, onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined): Promise<any | TResult> {\n    return this.then(void 0, onrejected);\n}", "import { executePromiseValue } from \"../../utils/execute\";\nimport { microTask } from \"../../utils/microTask\";\nimport withResolversImpl from \"./Promise.withResolvers\";\nimport type PromiseImpl from \"../index\";\nimport { getPromiseSpecies } from \"../../utils/species\";\n\n/**\n * Promise#then\n * \n * @param { Function } onfinally \n * @returns { PromiseImpl }\n */\nexport default function finallyImpl <TResult = any> (this: PromiseImpl<TResult>, onfinally?: (() => any) | null | undefined): Promise<TResult> {\n    if (typeof onfinally !== \"function\") return this.then();\n    const { promise, resolve, reject } = withResolversImpl.call(getPromiseSpecies((this as any).constructor));\n    {\n        this._.callback((value: any) => {\n            microTask(() => {\n                executePromiseValue(void 0, onfinally, () => resolve(value), reject);\n            });\n        }, (reason: any) => {\n            microTask(() => {\n                executePromiseValue(void 0, onfinally, () => reject(reason), reject);\n            });\n        });\n    }\n    return promise as Promise<TResult>;\n}", "/**\n * \u5B9E\u73B0Promise.resolve\n * \n * @param { any } value \n * @returns { Promise }\n */\nexport default function resolve<T>(this: PromiseConstructor, value?: T | PromiseLike<T>): Promise<Awaited<T>> {\n    return new this(resolve => { resolve(value as any) });\n}", "/**\n * \u5B9E\u73B0Promise.resolve\n * \n * @param { any } reason \n * @returns { Promise }\n */\nexport default function reject(this: PromiseConstructor, reason?: any): Promise<any> {\n    return new this((_, reject) => { reject(reason as any) });\n}", "import { isIterable } from \"../utils/types\";\n\n/**\n * \u6821\u9A8C new Promise \u5165\u53C2\n * \n * @param { any } iterable \n * @throws { TypeError } \n */\nexport function assertIterable (iterable: any)  {\n    if (isIterable(iterable)) return;\n    throw new TypeError(`${ getWrongIterableType(iterable) } is not iterable (cannot read property Symbol(Symbol.iterator))`);\n}\n  \n/**\n * \u83B7\u53D6\u9519\u8BEF\u7684\u6267\u884C\u5668\u7C7B\u578B\u8F93\u51FA\n * \n * @param { any } iterable\n * @returns { string }\n */\nexport function getWrongIterableType (iterable: any): string {\n    if (iterable === null) return \"object null\";\n    const type = typeof iterable;\n    if (type === \"number\" || type === \"boolean\") {\n        return `${ type } ${ String(iterable) }`;\n    }\n    return type\n}\n\n/** \u4E00\u4E9B\u9700\u8981\u663E\u793A\u4E3A `#<${ type }>` \u7684\u7C7B\u578B\u679A\u4E3E */\nexport const NATIVE_TYPES = new Set([\n    \"Object\",\n    \"Map\",\n    \"Set\",\n    \"Blob\",\n    \"ArrayBuffer\",\n    \"Promise\"\n]);", "import type PromiseImpl from \"../index\";\nimport { awaitCallback } from \"../../utils/await\";\nimport PromiseStateLabel from \"../../enum/PromiseStateLabel\";\nimport { assertIterable } from \"../../assert/assertIterable\";\n\n/**\n * Promise#then\n * \n * @param { Iterable } values\n * @returns { PromiseImpl }\n */\nexport default function allSettledImpl (this: typeof PromiseImpl<any>, values: any): Promise<PromiseSettledResult<any>[]> {\n    return new this((resolve) => {\n        {\n            /** \u5148\u65AD\u8A00\u662F\u5426\u53EF\u8FED\u4EE3 */\n            assertIterable(values);\n        }\n\n        /** \u5C06\u53EF\u8FED\u4EE3\u5BF9\u8C61\u8F6C\u5316\u4E3A\u6570\u7EC4 */\n        const valueArray = [...values];\n\n        /** \u5FEB\u6377\u77ED\u8DEF */\n        if (valueArray.length === 0) {\n            resolve([]);\n            return;\n        }\n        /** \u786E\u5B9A\u7684\u6570\u91CF */\n        let settled = 0;\n        /** \u5DF2\u7ECF\u786E\u5B9A\u7684\u7ED3\u679C\u6570\u7EC4 */\n        const settledResultaArray: PromiseSettledResult<any>[] = new Array(valueArray.length);\n        /** \u6572\u5B9A */\n        const sellted = (result: PromiseSettledResult<any>, index: number) => {\n            ++settled;\n            settledResultaArray[index] = result;\n            if (settled === settledResultaArray.length) {\n                resolve(settledResultaArray);\n            }\n        }\n        valueArray.forEach((value, index) => {\n            awaitCallback(value, (value: any) => {\n                sellted({ status: PromiseStateLabel.FULFILLED, value }, index);\n            }, (reason: any) => {\n                sellted({ status: PromiseStateLabel.REJECTED, reason }, index);\n            });\n        });\n    });\n}", "import type PromiseImpl from \"../index\";\nimport PromiseStateLabel from \"../../enum/PromiseStateLabel\";\nimport allSettledImpl from \"./Promise.allSettled\";\n\n/**\n * Promise#then\n * \n * @param { Iterable } value\n * @returns { PromiseImpl }\n */\nexport default function allImpl (this: typeof PromiseImpl<any>, values: any): Promise<any[]> {\n    return allSettledImpl.call(this, values).then(results => {\n        return results.map(result => {\n            if (result.status === PromiseStateLabel.FULFILLED) {\n                return result.value;\n            }\n            throw result.reason;\n        });\n    });\n}", "import type PromiseImpl from \"../index\";\nimport { awaitCallback } from \"../../utils/await\";\nimport PromiseStateLabel from \"../../enum/PromiseStateLabel\";\nimport { assertIterable } from \"../../assert/assertIterable\";\n\n/**\n * Promise#then\n * \n * @param { Iterable } values\n * @returns { PromiseImpl }\n */\nexport default function raceImpl (this: typeof PromiseImpl<any>, values: any): Promise<PromiseSettledResult<any>[]> {\n    return new this((resolve, reject) => {\n        {\n            /** \u5148\u65AD\u8A00\u662F\u5426\u53EF\u8FED\u4EE3 */\n            assertIterable(values);\n        }\n\n        /** \u5C06\u53EF\u8FED\u4EE3\u5BF9\u8C61\u8F6C\u5316\u4E3A\u6570\u7EC4 */\n        const valueArray = [...values];\n\n        /** \u5FEB\u6377\u77ED\u8DEF(\u59CB\u7EC8\u662Fpending\u72B6\u6001) */\n        if (valueArray.length === 0) {\n            return;\n        }\n        /** \u786E\u5B9A\u7684\u6570\u91CF */\n        let settled = 0;\n        /** \u6572\u5B9A */\n        const sellted = (result: PromiseSettledResult<any>, index: number) => {\n            if (settled > 0) return;\n            ++settled;\n            if (result.status === PromiseStateLabel.FULFILLED) {\n                resolve(result.value);\n            } else {\n                reject(result.reason);\n            }\n        }\n        valueArray.forEach((value, index) => {\n            awaitCallback(value, (value: any) => {\n                sellted({ status: PromiseStateLabel.FULFILLED, value }, index);\n            }, (reason: any) => {\n                sellted({ status: PromiseStateLabel.REJECTED, reason }, index);\n            });\n        });\n    });\n}", "import constructorImpl from \"./implements/constructor\";\nimport thenImpl from \"./implements/Promise#then\";\nimport catchImpl from \"./implements/Promise#catch\";\nimport finallyImpl from \"./implements/Promise#finally\";\nimport resolveImpl from \"./implements/Promise.resolve\";\nimport rejectImpl from \"./implements/Promise.reject\";\nimport allImpl from \"./implements/Promise.all\";\nimport allSettledImpl from \"./implements/Promise.allSettled\";\nimport raceImpl from \"./implements/Promise.race\";\nimport withResolversImpl from \"./implements/Promise.withResolvers\";\n\nexport default {\n    constructor: constructorImpl,\n    then: thenImpl,\n    catch: catchImpl,\n    finally: finallyImpl,\n    resolve: resolveImpl,\n    reject: rejectImpl,\n    all: allImpl,\n    allSettled: allSettledImpl,\n    race: raceImpl,\n    withResolvers: withResolversImpl\n}", "import { formatPromiseState } from \"../utils/state\";\nimport PromiseStateLabel from \"../enum/PromiseStateLabel\";\nimport PromiseKernel from \"../kernel\";\nimport { defineConfigurable, defineUnenumerable } from \"../utils/define\";\nimport impl from \"./implements\";\n\nexport default class PromiseImpl<T> implements Promise<T> {\n    protected readonly _!: PromiseKernel;\n  \n    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) {\n        impl.constructor.call(this, executor);\n    }\n\n    declare readonly [Symbol.toStringTag]: string;\n\n    //#region #PromiseState / #PromiseResult\n    /** \u6A21\u62DFPromise\u5728Console\u4E0B\u67E5\u770B\u72B6\u6001[[PromiseState]] */\n    get #PromiseState (): PromiseStateLabel {\n        return formatPromiseState(this._.state);\n    }\n\n    /** \u6A21\u62DFPromise\u5728Console\u4E0B\u67E5\u770B\u503C[[PromiseResult]] */\n    get #PromiseResult (): any {\n        return this._.result;\n    }\n    //#endregion\n\n    //#region [lib.es5.d.ts] then / catch\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    declare then: <TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    declare catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<T | TResult>;\n    //#endregion\n\n    //#region [lib.es2018.promise.d.ts] finally\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    declare finally: (onfinally?: (() => void) | null | undefined) => Promise<T>;\n    //#endregion\n  \n    static get [Symbol.species] () { return this; }\n\n    //#region [lib.es2015.promise.d.ts] static reject\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    static reject<T = never>(reason?: any): Promise<T> {\n        throw new Error(\"Method not implemented.\");\n    }\n    //#endregion\n  \n    //#region [lib.es2015.promise.d.ts] static resolve\n    /**\n     * Creates a new resolved promise.\n     * @returns A resolved promise.\n     */\n    static resolve(): Promise<void>;\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    static resolve<T>(value: T): Promise<Awaited<T>>;\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    static resolve<T>(value?: T | PromiseLike<T>): Promise<Awaited<T>> {\n        throw new Error(\"Method not implemented.\");\n    }\n    //#endregion\n  \n    //#region [lib.es2015.promise.d.ts / lib.es2018.iterable.d.ts] static all\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    static all<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }> {\n      throw new Error(\"Method not implemented.\");\n    }\n    //#endregion\n  \n    //#region [lib.es2015.promise.d.ts / lib.es2018.iterable.d.ts] static race\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    static race<T extends readonly unknown[] | []>(values: T): Promise<Awaited<T[number]>> {\n        throw new Error(\"Method not implemented.\");\n    }\n    //#endregion\n\n    //#region [lib.es2020.promise.d.ts] static allSettled\n    /**\n     * Creates a Promise that is resolved with an array of results when all\n     * of the provided Promises resolve or reject.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    allSettled<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: PromiseSettledResult<Awaited<T[P]>>; }>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all\n     * of the provided Promises resolve or reject.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    allSettled<T>(values: Iterable<T | PromiseLike<T>>): Promise<PromiseSettledResult<Awaited<T>>[]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all\n     * of the provided Promises resolve or reject.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    allSettled(values: any): Promise<PromiseSettledResult<any>[]> {\n        throw new Error(\"Method not implemented.\");\n    }\n    //#endregion\n  \n    //#region [lib.es2021.promise.d.ts] static any\n    /**\n     * The any function returns a promise that is fulfilled by the first given promise to be fulfilled, or rejected with an AggregateError containing an array of rejection reasons if all of the given promises are rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.\n     * @param values An array or iterable of Promises.\n     * @returns A new Promise.\n     */\n    any<T extends readonly unknown[] | []>(values: T): Promise<Awaited<T[number]>>;\n\n    /**\n     * The any function returns a promise that is fulfilled by the first given promise to be fulfilled, or rejected with an AggregateError containing an array of rejection reasons if all of the given promises are rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.\n     * @param values An array or iterable of Promises.\n     * @returns A new Promise.\n     */\n    any(values: any): Promise<Awaited<T>>;\n\n    /**\n     * The any function returns a promise that is fulfilled by the first given promise to be fulfilled, or rejected with an AggregateError containing an array of rejection reasons if all of the given promises are rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.\n     * @param values An array or iterable of Promises.\n     * @returns A new Promise.\n     */\n    any<T>(values?: any): Promise<any> {\n        throw new Error(\"Method not implemented.\");\n    }\n    //#endregion\n\n    //#region [lib.esnext.promise.d.ts] static withResolvers\n    /**\n     * Creates a new Promise and returns it in an object, along with its resolve and reject functions.\n     * @returns An object with the properties `promise`, `resolve`, and `reject`.\n     *\n     * ```ts\n     * const { promise, resolve, reject } = Promise.withResolvers<T>();\n     * ```\n     */\n    withResolvers<T>(): PromiseWithResolvers<T> {\n        throw new Error(\"Method not implemented.\");\n    }\n    //#endregion\n}\n\n{\n    defineConfigurable(PromiseImpl.prototype, Symbol.toStringTag, \"Promise\");\n    defineUnenumerable(PromiseImpl.prototype, \"then\", impl.then);\n    defineUnenumerable(PromiseImpl.prototype, \"catch\", impl.catch);\n    defineUnenumerable(PromiseImpl.prototype, \"finally\", impl.finally);\n    defineUnenumerable(PromiseImpl, \"resolve\", impl.resolve);\n    defineUnenumerable(PromiseImpl, \"reject\", impl.reject);\n    defineUnenumerable(PromiseImpl, \"all\", impl.all);\n    defineUnenumerable(PromiseImpl, \"allSettled\", impl.allSettled);\n    defineUnenumerable(PromiseImpl, \"race\", impl.race);\n    defineUnenumerable(PromiseImpl, \"withResolvers\", impl.withResolvers);\n}"],
  "mappings": "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",
  "names": ["PromiseState", "PromiseStateLabel", "type", "value", "value", "resolve", "reject", "resolve", "reject", "_resolve", "resolve", "reject", "resolve", "reject", "resolve", "reject", "resolve", "value", "resolve", "reject", "value"]
}
